#!/usr/bin/env python
PACKAGE = 'vector_pursuit_controller'
from dynamic_reconfigure.parameter_generator_catkin import *

gen = ParameterGenerator()

gen.add("controller_frequency", double_t, 0, "Control frequency apply for linear velocity scale", 20.0, 1.0, 50.0)
gen.add("k", double_t, 0, "k is a constant that relates the time taken for rotation and translation. The relationship is rotation_time = k * translation_time. Increasing k will result in a faster translation and decreasing k will, in turn, result in faster rotation.", 0.5, 5.0, 20.0)
gen.add("desired_linear_vel", double_t, 0, "Target linear velocity.", 0.5, 0.01, 2.0)
gen.add("desired_linear_vel_backwards", double_t, 0, "Target linear velocity when move backwards", 0.2, 0.01, 1.0)
gen.add("min_turning_radius", double_t, 0, "Minimum turning radius. The min_turning_radius of the controller should be equal to or less than the minimum turning radius of the planner (in case it is available). This ensures the controller can follow the path generated by the planner and not get stuck in a loop.", 0.25, 0.05, 2.0)
gen.add("lookahead_dist", double_t, 0, "The lookahead distance (m) to use to find the lookahead point when use_velocity_scaled_lookahead_dist is false.", 1.0, 0.1, 10.0)
gen.add("min_approach_linear_velocity", double_t, 0, "The minimum velocity (m/s) threshold to apply when approaching the goal to ensure progress. Must be > 0.01.", 0.05, 0.02, 1.0)
gen.add("approach_velocity_scaling_dist", double_t, 0, "The distance to goal at which velocity scaling will begin. Set to 0 to disable.", 1.0, 0.3, 3.0)
gen.add("min_lookahead_dist", double_t, 0, "The minimum lookahead distance (m) threshold when use_velocity_scaled_lookahead_dist is true.", 0.5, 0.1, 1.0)
gen.add("max_lookahead_dist", double_t, 0, "The maximum lookahead distance (m) threshold when use_velocity_scaled_lookahead_dist is true.", 1.5, 1.0, 5.0)
gen.add("lookahead_time", double_t, 0, "The time (s) to project the velocity by when use_velocity_scaled_lookahead_dist is true. Also known as the lookahead gain.", 1.5, 0.5, 10.0)
gen.add("use_velocity_scaled_lookahead_dist", bool_t, 0, "Whether to use the velocity scaled lookahead distances or constant lookahead_distance.", False)
gen.add("min_linear_velocity", double_t, 0, "	Magnitude of the minimum commandable linear velocity.", 0.1, 0.01, 1.0)
gen.add("max_allowed_time_to_collision_up_to_target", double_t, 0, "Maximum time allowed for collision checking.", 1.0, 1.0, 10.0)
gen.add("scale_factor", double_t, 0, "Scale footprint robot if you want.", 0.9, 0.1, 5.0)
gen.add("use_collision_detection", bool_t, 0, "Enable/disable collision detection.", True)
gen.add("use_cost_regulated_linear_velocity_scaling", bool_t, 0, "Enable/disable cost-regulated linear velocity scaling.", True)
gen.add("allow_reversing", bool_t, 0, "Will move in reverse if the lookahead point is behind the robot.", True)
gen.add("cost_scaling_dist", double_t, 0, "Distance for cost-based velocity scaling.", 1.0, 0.5, 5.0)
gen.add("cost_scaling_gain", double_t, 0, "Gain factor for cost-based velocity scaling.", 1.0, 0.01, 10.0)
gen.add("inflation_cost_scaling_factor", double_t, 0, "Factor for inflation cost scaling.", 3.0, 1.0, 10.0)
gen.add("max_angular_accel", double_t, 0, "Maximum angular acceleration.", 0.5, 0.1, 10.0)
gen.add("max_linear_accel", double_t, 0, "Maximum linear acceleration.", 0.5, 0.1, 10.0)
gen.add("max_lateral_accel", double_t, 0, "Maximum allowed lateral acceleration. This is used to slowdown the robot while making sharp turns. Higher values result in a higher achievable linear velocity at a turn.", 0.08, 0.01, 5.0)
gen.add("max_robot_pose_search_dist", double_t, 0, "Maximum search distance for target poses.", 10.0, 1.0, 20.0)
gen.add("use_interpolation", bool_t, 0, "Calculate lookahead point exactly at the lookahead distance. Otherwise select a discrete point on the path.", True)
gen.add("use_heading_from_path", bool_t, 0, "If set to true, uses the orientation from the path poses otherwise, computes appropriate orientations. Only set to true if ypu are using a planner that takes robot heading into account like Smac Planner.", False)
gen.add("yaw_tolerance", double_t, 0, "Goal yaw tolerance", 0.02, 0.01, 1.0)
gen.add("xy_goal_tolerance", double_t, 0, "Goal xy tolerance", 0.05, 0.01, 0.4)
gen.add("goal_angular_vel_scaling_angle", double_t, 0, "Smoother when rotate to goal", 10.0, 10.0, 90.0)
gen.add("goal_angle_scaling_factor", double_t, 0, "Scaling factor for rotate to goal", 0.1, 0.01, 10.0)
gen.add("rotate_to_goal_max_angular_vel", double_t, 0, "Max velocity for rotate to goal", 0.4, 0.1, 1.0)
gen.add("rotate_to_goal_min_angular_vel", double_t, 0, "Min velocity for rotate to goal", 0.05, 0.05, 1.0)
exit(gen.generate(PACKAGE, "vector_pursuit_controller", "VectorPursuitController"))